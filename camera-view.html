<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カメラ映像 - 謎解きシステム</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <button class="back-btn" onclick="goBack()">← 戻る</button>
    
    <div class="container">
        <h1>カメラ映像</h1>
        
        <div class="camera-container">
            <div class="video-container">
                <video id="remoteVideo" autoplay playsinline></video>
                <canvas id="delayCanvas" style="display: none;"></canvas>
                <p id="statusText">配信に接続中...</p>
            </div>
            
            <div class="delay-controls">
                <label for="delaySlider">遅延時間:</label>
                <input type="range" id="delaySlider" min="0" max="30" value="5" step="1" class="delay-slider">
                <span id="delayValue">5秒</span>
            </div>
            
            <div class="broadcast-id-input">
                <label for="broadcastIdInput">配信ID:</label>
                <input type="text" id="broadcastIdInput" placeholder="配信IDを入力してください" style="width: 300px; padding: 8px; margin: 0 10px;">
                <button class="camera-btn" id="pasteIdBtn">貼り付け</button>
            </div>
            
            <div class="camera-controls">
                <button class="camera-btn" id="connectBtn">接続開始</button>
                <button class="camera-btn" id="disconnectBtn" disabled>接続終了</button>
                <button class="camera-btn" id="fullscreenBtn">全画面表示</button>
                <button class="camera-btn" id="recordBtn" disabled>録画開始</button>
            </div>
            
            <div class="connection-info">
                <h3>接続情報</h3>
                <p>受信ID: <span id="peerId">準備中...</span></p>
                <p>接続状態: <span id="connectionStatus">準備中</span></p>
                <p>遅延状態: <span id="delayStatus">無効</span></p>
                <p>バッファ状態: <span id="bufferStatus">---</span></p>
            </div>
            
            <div class="receive-stats">
                <h3>受信統計</h3>
                <p>受信ビットレート: <span id="receiveBitrateStats">--- kbps</span></p>
                <p>受信フレームレート: <span id="receiveFpsStats">--- fps</span></p>
                <p>パケットロス: <span id="packetLossStats">--- %</span></p>
            </div>
            
            <div class="troubleshooting">
                <h3>⚠️ トラブルシューティング</h3>
                <ul>
                    <li><strong>配信ID:</strong> 配信側から正しいIDをコピーして貼り付け</li>
                    <li><strong>接続順序:</strong> 配信側を先に開始してから受信側を接続</li>
                    <li><strong>ネットワーク:</strong> 同じネットワークまたはインターネット経由</li>
                    <li><strong>デバッグ:</strong> 開発者ツールのコンソールでエラーを確認</li>
                    <li><strong>タイムアウト:</strong> 10秒以内に接続されない場合は再試行</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
    <script src="js/app.js"></script>
    <script>
        let peer = null;
        let call = null;
        let remoteStream = null;
        let frameQueue = [];
        let processor = null;
        let generator = null;
        let canvas = null;
        let ctx = null;
        let isConnected = false;
        let delayMs = 5000; // 5秒デフォルト
        let isProcessing = false;
        let broadcastId = null;

        // PeerJS接続を初期化
        function initializePeer() {
            // 受信側のランダムなpeerIDを生成
            const peerId = 'camera-viewer-' + Math.random().toString(36).substr(2, 9);
            
            console.log('🔄 PeerJS初期化開始 (受信側):', peerId);
            
            peer = new Peer(peerId, {
                host: '0.peerjs.com',
                port: 443,
                path: '/',
                secure: true,
                debug: 2, // デバッグレベルを追加
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' }
                    ]
                }
            });

            peer.on('open', function(id) {
                console.log('✅ PeerJS接続成功 (受信側):', id);
                document.getElementById('peerId').textContent = id;
                document.getElementById('connectionStatus').textContent = '接続可能';
                
                // 接続成功をユーザーに通知
                document.getElementById('statusText').textContent = '受信準備完了 - 配信IDを入力して接続してください';
            });

            peer.on('call', function(incomingCall) {
                console.log('通話要求を受信');
                incomingCall.answer();
                
                incomingCall.on('stream', function(stream) {
                    console.log('リモートストリーム受信');
                    remoteStream = stream;
                    handleRemoteStream(stream);
                });
                
                incomingCall.on('close', function() {
                    console.log('通話終了');
                    disconnectFromBroadcast();
                });
                
                incomingCall.on('error', function(error) {
                    console.error('通話エラー:', error);
                    disconnectFromBroadcast();
                });
            });

            peer.on('error', function(err) {
                console.error('❌ PeerJS エラー:', err);
                document.getElementById('connectionStatus').textContent = 'エラー: ' + err.type;
                
                // エラーの種類に応じて詳細なメッセージを表示
                let errorMessage = 'エラーが発生しました: ';
                switch (err.type) {
                    case 'network':
                        errorMessage += 'ネットワーク接続エラー';
                        break;
                    case 'server-error':
                        errorMessage += 'サーバーエラー';
                        break;
                    case 'peer-unavailable':
                        errorMessage += '配信IDが見つかりません';
                        break;
                    case 'browser-incompatible':
                        errorMessage += 'ブラウザが対応していません';
                        break;
                    default:
                        errorMessage += err.type;
                }
                
                document.getElementById('statusText').textContent = errorMessage;
                
                // 自動再接続
                if (err.type === 'network' || err.type === 'server-error') {
                    console.log('🔄 5秒後に自動再接続を試行します...');
                    setTimeout(() => {
                        initializePeer();
                    }, 5000);
                }
            });
        }

        // 配信IDを貼り付け
        function pasteBroadcastId() {
            navigator.clipboard.readText().then(text => {
                document.getElementById('broadcastIdInput').value = text;
            }).catch(err => {
                console.warn('クリップボード読み取りエラー:', err);
            });
        }

        // 配信に接続
        function connectToBroadcast() {
            if (!peer) {
                console.error('PeerJS が初期化されていません');
                return;
            }

            // 入力フィールドから配信IDを取得
            const inputField = document.getElementById('broadcastIdInput');
            const inputId = inputField.value.trim();
            
            if (!inputId) {
                alert('配信IDを入力してください');
                inputField.focus();
                return;
            }
            
            broadcastId = inputId;

            try {
                console.log('🔄 配信に接続中...', broadcastId);
                document.getElementById('statusText').textContent = '配信に接続中...';
                
                call = peer.call(broadcastId);
                
                if (!call) {
                    throw new Error('配信IDが見つかりません');
                }
                
                console.log('📞 通話要求を送信:', broadcastId);
                
                call.on('stream', function(stream) {
                    console.log('✅ 配信ストリームを受信');
                    remoteStream = stream;
                    handleRemoteStream(stream);
                    
                    document.getElementById('statusText').textContent = '配信を受信中...';
                    document.getElementById('connectionStatus').textContent = '接続済み';
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    isConnected = true;
                    console.log('🎬 映像配信開始');
                });
                
                call.on('close', function() {
                    console.log('📴 配信終了');
                    disconnectFromBroadcast();
                });
                
                call.on('error', function(error) {
                    console.error('❌ 通話エラー:', error);
                    document.getElementById('statusText').textContent = '通話エラー: ' + error.message;
                });
                
                // 接続状態を監視
                setTimeout(() => {
                    if (!isConnected) {
                        console.warn('⚠️ 接続タイムアウト - 配信IDまたは配信状態を確認してください');
                        document.getElementById('statusText').textContent = '接続タイムアウト - 配信IDまたは配信状態を確認してください';
                    }
                }, 10000); // 10秒でタイムアウト
                
            } catch (error) {
                console.error('❌ 配信への接続に失敗:', error);
                document.getElementById('statusText').textContent = '配信への接続に失敗: ' + error.message;
            }
        }

        // 配信から切断
        function disconnectFromBroadcast() {
            if (call) {
                call.close();
                call = null;
            }
            
            stopDelayBuffer();
            
            const video = document.getElementById('remoteVideo');
            video.srcObject = null;
            video.src = '';
            
            document.getElementById('statusText').textContent = '配信を停止しました';
            document.getElementById('connectionStatus').textContent = '切断済み';
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            
            isConnected = false;
            remoteStream = null;
        }

        // リモートストリームを処理
        function handleRemoteStream(stream) {
            console.log('ストリーム処理開始, 遅延:', delayMs + 'ms');
            
            if (delayMs > 0) {
                startDelayBuffer(stream);
            } else {
                // 遅延なしで直接表示
                const video = document.getElementById('remoteVideo');
                video.srcObject = stream;
                document.getElementById('delayStatus').textContent = '無効';
            }
        }

        // MediaStreamTrackProcessor を使用した高性能遅延バッファ
        function startDelayBuffer(stream) {
            try {
                // 前の処理を停止
                stopDelayBuffer();
                
                const videoTrack = stream.getVideoTracks()[0];
                if (!videoTrack) {
                    console.error('ビデオトラックが見つかりません');
                    return;
                }

                // MediaStreamTrackProcessor をサポートしているかチェック
                if (typeof MediaStreamTrackProcessor === 'undefined') {
                    console.warn('MediaStreamTrackProcessor が利用できません。従来の方法を使用します。');
                    fallbackDelayBuffer(stream);
                    return;
                }

                processor = new MediaStreamTrackProcessor({track: videoTrack});
                const reader = processor.readable.getReader();
                
                canvas = document.getElementById('delayCanvas');
                ctx = canvas.getContext('2d');
                
                // フレームキューをクリア
                frameQueue = [];
                isProcessing = true;
                
                // フレーム読み取りループ
                async function readFrames() {
                    try {
                        while (isProcessing) {
                            const result = await reader.read();
                            if (result.done) break;
                            
                            const frame = result.value;
                            const timestamp = performance.now();
                            
                            // フレームをキューに追加
                            frameQueue.push({
                                frame: frame,
                                timestamp: timestamp
                            });
                            
                            // キューのサイズを制限（メモリ使用量を抑制）
                            if (frameQueue.length > 300) { // 10秒分程度
                                const oldFrame = frameQueue.shift();
                                oldFrame.frame.close();
                            }
                        }
                    } catch (error) {
                        console.error('フレーム読み取りエラー:', error);
                    }
                }
                
                // 遅延描画ループ
                function renderDelayedFrames() {
                    if (!isProcessing) return;
                    
                    const now = performance.now();
                    const targetTime = now - delayMs;
                    
                    // 遅延時間に達したフレームを検索
                    const frameIndex = frameQueue.findIndex(item => item.timestamp <= targetTime);
                    
                    if (frameIndex !== -1) {
                        const frameItem = frameQueue[frameIndex];
                        const frame = frameItem.frame;
                        
                        try {
                            // キャンバスにフレームを描画
                            canvas.width = frame.displayWidth || 640;
                            canvas.height = frame.displayHeight || 360;
                            ctx.drawImage(frame, 0, 0);
                            
                            // キャンバスをビデオ要素に表示
                            const video = document.getElementById('remoteVideo');
                            
                            // MediaSourceを使ってキャンバスをビデオとして表示
                            canvas.toBlob(function(blob) {
                                if (blob) {
                                    const url = URL.createObjectURL(blob);
                                    
                                    // 前のURLをクリーンアップ
                                    if (video.src && video.src.startsWith('blob:')) {
                                        URL.revokeObjectURL(video.src);
                                    }
                                    
                                    video.src = url;
                                    video.currentTime = 0;
                                }
                            }, 'image/jpeg', 0.9);
                            
                        } catch (error) {
                            console.error('フレーム描画エラー:', error);
                        }
                        
                        // 使用済みフレームをクリーンアップ
                        for (let i = 0; i <= frameIndex; i++) {
                            frameQueue[i].frame.close();
                        }
                        frameQueue.splice(0, frameIndex + 1);
                    }
                    
                    requestAnimationFrame(renderDelayedFrames);
                }
                
                // 処理を開始
                readFrames();
                renderDelayedFrames();
                
                document.getElementById('delayStatus').textContent = `有効 (${delayMs/1000}秒)`;
                
            } catch (error) {
                console.error('遅延バッファの開始に失敗:', error);
                fallbackDelayBuffer(stream);
            }
        }

        // フォールバック遅延バッファ（従来の方法）
        function fallbackDelayBuffer(stream) {
            console.log('フォールバック遅延バッファを使用');
            
            const video = document.getElementById('remoteVideo');
            const canvas = document.getElementById('delayCanvas');
            const ctx = canvas.getContext('2d');
            
            // 一時的なビデオ要素を作成
            const tempVideo = document.createElement('video');
            tempVideo.srcObject = stream;
            tempVideo.muted = true;
            tempVideo.autoplay = true;
            tempVideo.playsinline = true;
            
            let frameBuffer = [];
            isProcessing = true;
            
            tempVideo.addEventListener('loadedmetadata', function() {
                canvas.width = tempVideo.videoWidth || 640;
                canvas.height = tempVideo.videoHeight || 360;
                
                function captureFrame() {
                    if (!isProcessing) return;
                    
                    if (tempVideo.readyState >= 2) {
                        ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        frameBuffer.push({
                            data: imageData,
                            timestamp: performance.now()
                        });
                        
                        // バッファサイズ制限
                        if (frameBuffer.length > 300) {
                            frameBuffer.shift();
                        }
                        
                        // 遅延フレームを表示
                        const now = performance.now();
                        const targetTime = now - delayMs;
                        const frameToShow = frameBuffer.find(frame => frame.timestamp <= targetTime);
                        
                        if (frameToShow) {
                            ctx.putImageData(frameToShow.data, 0, 0);
                            frameBuffer = frameBuffer.filter(frame => frame.timestamp > targetTime);
                        }
                    }
                    
                    setTimeout(captureFrame, 33); // 約30fps
                }
                
                captureFrame();
            });
            
            // キャンバスをビデオ要素として表示
            const canvasStream = canvas.captureStream(30);
            video.srcObject = canvasStream;
            
            document.getElementById('delayStatus').textContent = `有効 (${delayMs/1000}秒) - フォールバック`;
        }

        // 遅延バッファを停止
        function stopDelayBuffer() {
            isProcessing = false;
            
            if (processor) {
                try {
                    processor.readable.cancel();
                } catch (e) {
                    console.warn('Processor停止エラー:', e);
                }
                processor = null;
            }
            
            if (generator) {
                try {
                    generator.close();
                } catch (e) {
                    console.warn('Generator停止エラー:', e);
                }
                generator = null;
            }
            
            // フレームキューをクリーンアップ
            frameQueue.forEach(item => {
                if (item.frame && item.frame.close) {
                    item.frame.close();
                }
            });
            frameQueue = [];
        }

        // 受信統計を更新
        function updateReceiveStats() {
            if (!call || !call.peerConnection) return;
            
            call.peerConnection.getStats().then(stats => {
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                        const bitrate = Math.round((report.bytesReceived * 8) / 1000); // kbps
                        const fps = report.framesPerSecond || 0;
                        const packetsLost = report.packetsLost || 0;
                        const packetsReceived = report.packetsReceived || 1;
                        const lossPercentage = ((packetsLost / (packetsLost + packetsReceived)) * 100).toFixed(2);
                        
                        document.getElementById('receiveBitrateStats').textContent = bitrate + ' kbps';
                        document.getElementById('receiveFpsStats').textContent = fps + ' fps';
                        document.getElementById('packetLossStats').textContent = lossPercentage + ' %';
                    }
                });
            }).catch(err => {
                console.warn('受信統計取得エラー:', err);
            });
            
            // バッファ状態を更新
            const bufferLength = frameQueue.length;
            const bufferTimeMs = bufferLength > 0 ? 
                (performance.now() - frameQueue[0].timestamp) : 0;
            document.getElementById('bufferStatus').textContent = 
                `${bufferLength}フレーム (${Math.round(bufferTimeMs)}ms)`;
        }

        // 遅延時間を更新
        function updateDelayTime() {
            const slider = document.getElementById('delaySlider');
            delayMs = parseInt(slider.value) * 1000; // 秒をミリ秒に変換
            document.getElementById('delayValue').textContent = (delayMs/1000) + '秒';
            
            console.log('遅延時間更新:', delayMs + 'ms');
            
            // 接続中の場合は遅延設定を再適用
            if (isConnected && remoteStream) {
                handleRemoteStream(remoteStream);
            }
        }

        // 全画面表示
        function toggleFullscreen() {
            const video = document.getElementById('remoteVideo');
            
            if (!document.fullscreenElement) {
                video.requestFullscreen().catch(err => {
                    console.error('フルスクリーン表示に失敗:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // 戻るボタン
        function goBack() {
            disconnectFromBroadcast();
            if (peer) {
                peer.destroy();
            }
            window.location.href = 'index.html';
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            initializePeer();
            
            // Canvas要素を準備
            canvas = document.getElementById('delayCanvas');
            ctx = canvas.getContext('2d');
            
            // イベントリスナーを追加
            document.getElementById('connectBtn').addEventListener('click', connectToBroadcast);
            document.getElementById('disconnectBtn').addEventListener('click', disconnectFromBroadcast);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('delaySlider').addEventListener('input', updateDelayTime);
            document.getElementById('pasteIdBtn').addEventListener('click', pasteBroadcastId);
            
            // Enterキーでも接続
            document.getElementById('broadcastIdInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    connectToBroadcast();
                }
            });
            
            // 初期遅延値を設定
            updateDelayTime();
            
            // 定期的に統計を更新
            setInterval(updateReceiveStats, 1000);
            
            // ブラウザサポート状況を表示
            const supportStatus = typeof MediaStreamTrackProcessor !== 'undefined' 
                ? 'サポート済み (高性能)' 
                : 'フォールバック モード';
            console.log('MediaStreamTrackProcessor:', supportStatus);
            document.getElementById('statusText').textContent = 'MediaStreamTrackProcessor: ' + supportStatus;
        });

        // ページ離脱時のクリーンアップ
        window.addEventListener('beforeunload', function() {
            disconnectFromBroadcast();
            if (peer) {
                peer.destroy();
            }
        });
    </script>
</body>
</html> 